from tidyms.fileio import SimulatedMSData
from tidyms.lcms import Chromatogram
from tidyms.raw_data_utils import _match_mz
import pytest
import numpy as np
import tidyms as ms


mz_list = np.array([200, 250, 300, 420, 450])


@pytest.fixture
def sim_ms_data():
    mz = np.array(mz_list)
    rt = np.linspace(0, 100, 100)

    # simulated features params
    mz_params = np.array([mz_list, [3, 10, 5, 31, 22]])
    mz_params = mz_params.T
    rt_params = np.array(
        [[30, 40, 60, 80, 80], [1, 2, 2, 3, 3], [1, 1, 1, 1, 1]]
    )
    rt_params = rt_params.T

    noise_level = 0.1
    sim_exp = SimulatedMSData(mz, rt, mz_params, rt_params, noise=noise_level)
    return sim_exp


def test_make_roi(sim_ms_data):
    roi_list = ms.make_roi(
        sim_ms_data,
        tolerance=0.005,
        max_missing=0,
        min_length=1
    )
    assert len(roi_list) == sim_ms_data.mz_params.shape[0]


def test_make_roi_targeted_mz(sim_ms_data):
    # the first three m/z values generated by simulated experiment are used
    targeted_mz = sim_ms_data.mz_params[:, 0][:3]
    roi_list = ms.make_roi(
        sim_ms_data,
        tolerance=0.005,
        max_missing=0,
        min_length=1,
        min_intensity=0,
        targeted_mz=targeted_mz)
    assert len(roi_list) == targeted_mz.size


def test_make_roi_min_intensity(sim_ms_data):
    min_intensity = 15
    roi_list = ms.make_roi(
        sim_ms_data,
        tolerance=0.005,
        max_missing=0,
        min_length=1,
        min_intensity=min_intensity,
    )
    # only two roi should have intensities greater than 15
    assert len(roi_list) == 2


def test_make_roi_multiple_match_closest(sim_ms_data):
    roi_list = ms.make_roi(
        sim_ms_data,
        tolerance=0.005,
        max_missing=0,
        min_length=1,
        multiple_match="closest")
    assert len(roi_list) == sim_ms_data.mz_params.shape[0]


def test_make_roi_multiple_match_reduce_merge(sim_ms_data):
    # set a tolerance such that two mz values are merged
    # test is done in targeted mode to force a multiple match by removing
    # one of the mz values
    targeted_mz = sim_ms_data.mz_params[:, 0]
    targeted_mz = np.delete(targeted_mz, 3)
    tolerance = 31
    roi_list = ms.make_roi(
        sim_ms_data,
        tolerance=tolerance,
        max_missing=0,
        min_length=1,
        targeted_mz=targeted_mz)
    assert len(roi_list) == (sim_ms_data.mz_params.shape[0] - 1)


def test_make_roi_multiple_match_reduce_custom_mz_reduce(sim_ms_data):
    roi_list = ms.make_roi(
        sim_ms_data,
        tolerance=0.005,
        max_missing=0,
        min_length=1,
        mz_reduce=np.median
    )
    assert len(roi_list) == sim_ms_data.mz_params.shape[0]


def test_make_roi_multiple_match_reduce_custom_sp_reduce(sim_ms_data):
    roi_list = ms.make_roi(
        sim_ms_data,
        tolerance=0.005,
        max_missing=0,
        min_length=1,
        sp_reduce=lambda x: 1
    )
    assert len(roi_list) == sim_ms_data.mz_params.shape[0]


def test_make_roi_invalid_multiple_match(sim_ms_data):
    with pytest.raises(ValueError):
        ms.make_roi(
            sim_ms_data,
            tolerance=0.005,
            max_missing=0,
            min_length=0,
            multiple_match="invalid-value"
        )


# # test accumulate spectra

def test_accumulate_spectra_centroid(sim_ms_data):
    start_time = sim_ms_data.rt.min()
    end_time = sim_ms_data.rt.max()
    sp = ms.accumulate_spectra(
        sim_ms_data, start_time=start_time, end_time=end_time)
    assert sp.mz.size == sim_ms_data.mz_params.shape[0]


def test_accumulate_spectra_centroid_subtract_left(sim_ms_data):
    start_time = sim_ms_data.rt[70]
    end_time = sim_ms_data.rt[90]
    subtract_left_time = sim_ms_data.rt[20]
    sp = ms.accumulate_spectra(
        sim_ms_data,
        start_time=start_time,
        end_time=end_time,
        subtract_left_time=subtract_left_time
    )
    # only two peaks at rt 80 should be present
    assert sp.mz.size == 2


# test make_chromatogram

def test_make_chromatograms(sim_ms_data):
    # test that the chromatograms generated are valid

    # create chromatograms
    n_sp = sim_ms_data.get_n_spectra()
    n_mz = sim_ms_data.mz_params.shape[0]
    rt = np.zeros(n_sp)
    chromatogram = np.zeros((n_mz, n_sp))
    for scan, sp in sim_ms_data.get_spectra_iterator():
        sp = sim_ms_data.get_spectrum(scan)
        rt[scan] = sp.time
        chromatogram[:, scan] = sp.spint

    expected_chromatograms = [Chromatogram(rt, x) for x in chromatogram]
    test_chromatograms = ms.make_chromatograms(sim_ms_data, mz_list)
    assert len(test_chromatograms) == len(expected_chromatograms)
    for ec, tc in zip(expected_chromatograms, test_chromatograms):
        assert np.array_equal(ec.time, tc.time)
        assert np.array_equal(ec.spint, tc.spint)


def test_make_chromatograms_accumulator_mean(sim_ms_data):
    ms.make_chromatograms(sim_ms_data, mz_list, accumulator="mean")
    assert True


def test_make_tic(sim_ms_data):
    ms.make_tic(sim_ms_data, kind="tic")
    assert True


def test_make_tic_bpi(sim_ms_data):
    ms.make_tic(sim_ms_data, kind="bpi")
    assert True


# test match_mz

def test_match_mz_no_multiple_matches():
    tolerance = 2
    mz1 = np.array([50, 75, 100, 125, 150])
    mz2 = np.array([40, 51, 78, 91, 99, 130, 150])
    sp2 = np.array([100] * mz2.size)
    # expected values for match/no match indices
    mz1_match_index = np.array([0, 2, 4], dtype=int)
    mz2_match_index = np.array([1, 4, 6], dtype=int)
    mz2_no_match_index = np.array([0, 2, 3, 5], dtype=int)
    mode = "closest"
    test_mz1_index, mz2_match, sp2_match, mz2_no_match, sp2_no_match = \
        _match_mz(mz1, mz2, sp2, tolerance, mode, np.mean, np.mean)
    # test match index
    assert np.array_equal(mz1_match_index, test_mz1_index)
    # test match mz and sp values
    assert np.array_equal(mz2[mz2_match_index], mz2_match)
    assert np.array_equal(sp2[mz2_match_index], sp2_match)
    # test no match mz and sp values
    assert np.array_equal(mz2[mz2_no_match_index], mz2_no_match)
    assert np.array_equal(sp2[mz2_no_match_index], sp2_no_match)


def test_match_mz_no_matches():
    tolerance = 2
    mz1 = np.array([50, 75, 100, 125, 150])
    mz2 = np.array([40, 53, 78, 91, 97, 130, 154])
    sp2 = np.array([100] * mz2.size)
    # expected values for match/no match indices
    mz1_match_index = np.array([], dtype=int)
    mz2_match_index = np.array([], dtype=int)
    mz2_no_match_index = np.array([0, 1, 2, 3, 4, 5, 6], dtype=int)
    mode = "closest"
    test_mz1_index, mz2_match, sp2_match, mz2_no_match, sp2_no_match = \
        _match_mz(mz1, mz2, sp2, tolerance, mode, np.mean, np.mean)
    # test match index
    assert np.array_equal(mz1_match_index, test_mz1_index)
    # test match mz and sp values
    assert np.array_equal(mz2[mz2_match_index], mz2_match)
    assert np.array_equal(sp2[mz2_match_index], sp2_match)
    # test no match mz and sp values
    assert np.array_equal(mz2[mz2_no_match_index], mz2_no_match)
    assert np.array_equal(sp2[mz2_no_match_index], sp2_no_match)


def test_match_mz_all_match():
    tolerance = 2
    mz1 = np.array([50, 75, 100, 125, 150])
    mz2 = np.array([51, 77, 99, 126, 150])
    sp2 = np.array([100] * mz2.size)
    # expected values for match/no match indices
    mz1_match_index = np.array([0, 1, 2, 3, 4], dtype=int)
    mz2_match_index = np.array([0, 1, 2, 3, 4], dtype=int)
    mz2_no_match_index = np.array([], dtype=int)
    mode = "closest"
    test_mz1_index, mz2_match, sp2_match, mz2_no_match, sp2_no_match = \
        _match_mz(mz1, mz2, sp2, tolerance, mode, np.mean, np.mean)
    # test match index
    assert np.array_equal(mz1_match_index, test_mz1_index)
    # test match mz and sp values
    assert np.array_equal(mz2[mz2_match_index], mz2_match)
    assert np.array_equal(sp2[mz2_match_index], sp2_match)
    # test no match mz and sp values
    assert np.array_equal(mz2[mz2_no_match_index], mz2_no_match)
    assert np.array_equal(sp2[mz2_no_match_index], sp2_no_match)


def test_match_mz_multiple_matches_mode_closest():
    tolerance = 2
    mz1 = np.array([50, 75, 100, 125, 150])
    mz2 = np.array([49, 51, 78, 99, 100, 101, 126, 150, 151])
    sp2 = np.array([100] * mz2.size)
    # expected values for match/no match indices
    # in `closest` mode, argmin is used to select the closest value. If more
    # than one value has the same difference, the first one in the array is
    # going to be selected.
    mz1_match_index = np.array([0, 2, 3, 4], dtype=int)
    mz2_match_index = np.array([0, 4, 6, 7], dtype=int)
    mz2_no_match_index = np.array([1, 2, 3, 5, 8], dtype=int)
    mode = "closest"
    test_mz1_index, mz2_match, sp2_match, mz2_no_match, sp2_no_match = \
        _match_mz(mz1, mz2, sp2, tolerance, mode, np.mean, np.mean)
    # test match index
    assert np.array_equal(mz1_match_index, test_mz1_index)
    # test match mz and sp values
    assert np.array_equal(mz2[mz2_match_index], mz2_match)
    assert np.array_equal(sp2[mz2_match_index], sp2_match)
    # test no match mz and sp values
    assert np.array_equal(mz2[mz2_no_match_index], mz2_no_match)
    assert np.array_equal(sp2[mz2_no_match_index], sp2_no_match)


def test_match_mz_multiple_matches_mode_reduce():
    tolerance = 2
    mz1 = np.array([50, 75, 100, 125, 150], dtype=float)
    mz2 = np.array([49, 51, 78, 99, 100, 101, 126, 150, 151], dtype=float)
    sp2 = np.array([100] * mz2.size, dtype=float)
    # expected values for match/no match indices
    # in `closest` mode, argmin is used to select the closest value. If more
    # than one value has the same difference, the first one in the array is
    # going to be selected.
    mz1_match_index = np.array([0, 2, 3, 4], dtype=int)
    mz2_match_index = np.array([0, 1, 3, 4, 5, 6, 7, 8], dtype=int)
    mz2_no_match_index = np.array([2], dtype=int)
    expected_mz2_match = [50.0, 100.0, 126.0, 150.5]
    expected_sp2_match = [200, 300, 100, 200]
    mode = "reduce"
    test_mz1_index, mz2_match, sp2_match, mz2_no_match, sp2_no_match = \
        _match_mz(mz1, mz2, sp2, tolerance, mode, np.mean, np.sum)
    # test match index
    assert np.array_equal(mz1_match_index, test_mz1_index)
    # test match mz and sp values
    assert np.allclose(mz2_match, expected_mz2_match)
    assert np.allclose(sp2_match, expected_sp2_match)
    # test no match mz and sp values
    assert np.array_equal(mz2[mz2_no_match_index], mz2_no_match)
    assert np.array_equal(sp2[mz2_no_match_index], sp2_no_match)


def test_match_mz_invalid_mode():
    tolerance = 2
    mz1 = np.array([50, 75, 100, 125, 150])
    mz2 = np.array([49, 51, 78, 99, 100, 101, 126, 150, 151])
    sp2 = np.array([100] * mz2.size)
    # expected values for match/no match indices
    # in closest mode, argmin is used to select the closest value. If more
    # than one value has the same difference, the first one in the array is
    # going to be selected.
    mz1_match_index = np.array([0, 2, 3, 4], dtype=int)
    mz2_match_index = np.array([0, 4, 6, 7], dtype=int)
    mz2_no_match_index = np.array([1, 2, 3, 5, 8], dtype=int)
    mode = "invalid-mode"
    with pytest.raises(ValueError):
        test_mz1_index, mz2_match, sp2_match, mz2_no_match, sp2_no_match = \
            _match_mz(mz1, mz2, sp2, tolerance, mode, np.mean, np.mean)

# def test_accumulate_spectra_profile(profile_mzml):
#     sp = ms.accumulate_spectra(profile_mzml, start_time=5, end_time=10)
#     assert sp.mz.size == sp.spint.size
